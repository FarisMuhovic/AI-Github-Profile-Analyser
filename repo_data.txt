[
{'name': 'kadaif',
'full_name': 'Muha0644/kadaif',
'default_branch': 'master',
'html_url': 'https://github.com/Muha0644/kadaif',
'clone_url': 'https://github.com/Muha0644/kadaif.git',
'description': 'HoI4 Modding Tool That Does It All! Now with a QT based GUI, all your work wil be easier!',
'forks_count': 1,
'open_issues_count': 0,
'pushed_at': '2024-05-25T21:20:36Z',
'topics': [],
'languages': {'C++': 52463, 'C': 1916, 'CMake': 1365},
 'readme': "# Kadaif - HoI4 Modding Tool\n**Kadaif** is a cross-platform tool meant to help you make mods for Hearts of Iron IV. With VSCode and all it's extensions, managing a massive codebase is easy, but it would be a lot easier if the code was well written to begin with.<br>\nMost HoI 4 modders are not expert developers, so obvisouly the code they write will not be perfect (pretty shit in other words). That's where kadaif comes in!<br>\n<br>\nKadaif aims to automate most boring things like making events, focuses, and gfx files. You can simply use the GUI and then generate everything. You don't even have to copy and paste, you can just specify the file you want to use and it will even detect existing stuff so you can edit it. When you combine this with VSC and it's extensions, your mod will have better performance and the code will look neater. \n\n### Kadaif has cool features such as:\n* automatic code generation\n* localization editor\n* gfx/spriteType editor\n* convert all `.dds` files to BC3/DTX5 (to save space)\n* _more features to be added in full release!_\n<br><br>\n\n# Installation\n Download a binary from the [releases tab](https://github.com/Muha0644/kadaif/releases), or compile from source if you want the latest and greatest. If you use a Mac... I'm really sorry for you. Here, have a cookie üç™<br>\n Anyway here is how to compile from source if you want to:<br>\n ## Install Qt & Dependencies\n  ### <em>Windows</em>\n  You can check out the official [install guide](https://doc.qt.io/qt-6/get-and-install-qt.html) for Qt6 which requires making an account. You will also need to install [Image Magick](https://imagemagick.org/), so that the command `magick` works when run from cmd. (basically make sure `magick.exe` exists in your system32 directory or other place that windows knows about)\n  ### <em>Linux</em>\n Arch: `sudo pacman -Syu qt6-base qt6-doc qt6-tools qt6-translations imagemagick`<br>\n Debian: [idk, you can make a PR to add the command]<br>\n RedHat: [same]<br>\n\n  ### <em>Compile Qt from source</em>\n You can also compile Qt from [source](https://www.qt.io/offline-installers). This will, of course, be a lot more difficult and take a long time to compile, but it's worth it if you don't want to make an account you will never need. To compile Qt6 from source, follow this guide for [linux](https://doc.qt.io/qt-6/linux-building.html) or this one for [windows](https://doc.qt.io/qt-6/windows-building.html). \n ## Install Kadaif\n  First make sure you have `imagemagick` installed, then \n  download and install kadaif:\n* `git clone https://github.com/Muha0644/kadaif`\n* `cd kadaif`\n* `cmake .`\n* `cmake --build .`\n\n\nYeah you're probabbly better off just downloading a premade binary...\n\nOf course if you use Arch Linux there is an AUR package: `kadaif-git` or `kadaif-bin` (not yet, this text is a placeholder)\n<br><br>\n\n# Sponsored section\n~~This section is an advertisement for a mod i'm working on. Check out **Waves of the Danube (WotD)** - A TNO submod that aims to add content for Hungary, Croatia, Romania, and eventually the rest of the Balkans.~~\n\n~~Naturally, if you want Waves of the Danube to come out sooner. A larger team would be needed. If you have good GFX skills, writing skills or god bless us, have coding knowledge in HOI4 (or C++). Please join [our discord](https://discord.gg/kXsaS6jzsH)!~~\n\nYeah, this submod is deader than Kissinger... The entire team kind of just gave up unfortunately...<br><br>\n\n# License\nThis code is licensed under GPL 3.0, that means you can do whatever you want with it, modify it, distibute it, you can even use it for commercial purposes. The only thing you can't do is sublicense it, I.E. use a license other than GPL 3.0.\n\nYou have to include a copy of the [GPL 3.0 license](https://github.com/Muha0644/kadaif/blob/master/LICENSE) in any code that derives from this code. You also _have_ to include install instructions and a list of all significant changes as well as a reference to the original code (basically just use git and you should be fine).<br><br>\n\n# Contributing\nIf you want to add a feature or fix a bug, just fork this repo, fix it, and submit a pull request. Your name will be added in the credits.<br>\nI recommed using QtCreator, because thats what I used, and also because it's just got everything you need. It's a great C++ IDE in general, and working with Qt is less painful using it.\n<br><br>\n\n# Credits\n* muha0644\n* monkebanana8\n* bog1sart\n* et. al.\n",
 'structure': {'sha': 'a4d160a9fc01c33fe9b8d065e40fbe376e95f48c', 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/trees/a4d160a9fc01c33fe9b8d065e40fbe376e95f48c',
'tree': [{'path': '.gitignore', 'mode': '100644', 'type': 'blob', 'sha': '71e851641f62e02eb51c1fec731748158af32d4d', 'size': 345,
 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/71e851641f62e02eb51c1fec731748158af32d4d'},{'path': 'CMakeLists.txt',
 'mode': '100644',
 'type': 'blob',
 'sha': '48eed8a26ae4ae255598bbcd84f8b4c9d54ce9c4',
    'size': 1365,
    'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/48eed8a26ae4ae255598bbcd84f8b4c9d54ce9c4'},

     {'path': 'LICENSE',
     'mode': '100644',
     'type': 'blob',
     'sha': 'f288702d2fa16d3cdf0035b15a9fcbc552cd88e7',
     'size': 35149,
     'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/f288702d2fa16d3cdf0035b15a9fcbc552cd88e7'},
     {'path': 'README.md',
      'mode': '100644',
      'type': 'blob',
       'sha': '59c7033ffbc250a8648738ab69d670e54f8a2fe5',
     'size': 4444,
     'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/59c7033ffbc250a8648738ab69d670e54f8a2fe5'}, {'path': 'config.h', 'mode': '100644', 'type': 'blob', 'sha': '3e0d451454ef8dff44b13c758309baba30e61ea6', 'size': 1304, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/3e0d451454ef8dff44b13c758309baba30e61ea6'}, {'path': 'dataclass.cpp', 'mode': '100644', 'type': 'blob', 'sha': '64cb5b992aece124596cb2f17f3059e66d1df6e2', 'size': 1644, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/64cb5b992aece124596cb2f17f3059e66d1df6e2'}, {'path': 'dataclass.h', 'mode': '100644', 'type': 'blob', 'sha': '98dd356658cd1246ca1cae5f83fb64e76169a74e', 'size': 854, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/98dd356658cd1246ca1cae5f83fb64e76169a74e'}, {'path': 'features', 'mode': '100644', 'type': 'blob', 'sha': 'f0e65b1728ccf09c5760a09dbc56b42c4363fbf6', 'size': 318, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/f0e65b1728ccf09c5760a09dbc56b42c4363fbf6'}, {'path': 'flowlayout.cpp', 'mode': '100644', 'type': 'blob', 'sha': '601ee0d1f5ef51794a98c1de48e73bd5dfe70ac3', 'size': 5838, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/601ee0d1f5ef51794a98c1de48e73bd5dfe70ac3'}, {'path': 'flowlayout.h', 'mode': '100644', 'type': 'blob', 'sha': '3971a089832523ffc7d2940e0cee20e1cc303419', 'size': 3415, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/3971a089832523ffc7d2940e0cee20e1cc303419'}, {'path': 'gfx', 'mode': '040000', 'type':
     'tree', 'sha': 'c445bfdffe0ca39a7719a91273fc5ddb7cbbf839', 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/trees/c445bfdffe0ca39a7719a91273fc5ddb7cbbf839'}, {'path': 'gfx/form.ui', 'mode': '100644', 'type': 'blob', 'sha': 'e71fa09aba21e1aa289b57601a5f3e3ee5e99436', 'size': 1512, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/e71fa09aba21e1aa289b57601a5f3e3ee5e99436'}, {'path': 'gfx/gfxeditor.cpp', 'mode': '100644', 'type': 'blob', 'sha': '976a74c6bce924034fc3d6f7edf0efdc78e9cb0e', 'size': 2153, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/976a74c6bce924034fc3d6f7edf0efdc78e9cb0e'}, {'path': 'gfx/gfxeditor.h', 'mode': '100644', 'type': 'blob', 'sha': '8684a4e46aada6d49714e348a850cb8bbd6d5fd0', 'size': 513, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/8684a4e46aada6d49714e348a850cb8bbd6d5fd0'}, {'path': 'gfx/gfxeditor.ui', 'mode': '100644', 'type': 'blob', 'sha': '5486e0abf2e844d3f41894b2ace2aaa2ba97f04d', 'size': 2680, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/5486e0abf2e844d3f41894b2ace2aaa2ba97f04d'}, {'path': 'gfx/gfxstuff.cpp', 'mode': '100644', 'type': 'blob', 'sha': '3a5f7b0e1ac3d4e9f0401af320dc12c1b4a9dcf6', 'size': 12737, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/3a5f7b0e1ac3d4e9f0401af320dc12c1b4a9dcf6'}, {'path': 'gfx/gfxstuff.h', 'mode': '100644', 'type': 'blob', 'sha': '3f57b75dca6b560ffa31b7d433c9137fbee3cd80', 'size': 1771, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/3f57b75dca6b560ffa31b7d433c9137fbee3cd80'}, {'path': 'loc', 'mode': '040000', 'type': 'tree', 'sha': '6d46021ef4856589ddde488c84094ad942dd621e', 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/trees/6d46021ef4856589ddde488c84094ad942dd621e'}, {'path': 'loc/loceditor.cpp', 'mode': '100644', 'type': 'blob', 'sha': 'fb0a43634ebf50e0c4db909dbf36bbe5157c3868', 'size': 4301, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/fb0a43634ebf50e0c4db909dbf36bbe5157c3868'}, {'path': 'loc/loceditor.h', 'mode': '100644', 'type': 'blob', 'sha': 'dcce83692c9f5d2c97b9f6657481129924350be1', 'size': 1396, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/dcce83692c9f5d2c97b9f6657481129924350be1'}, {'path': 'loc/loceditor.ui', 'mode': '100644', 'type': 'blob', 'sha': '748af13de2b77dae0c9ce56c009b054027417222', 'size': 2571, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/748af13de2b77dae0c9ce56c009b054027417222'}, {'path': 'loc/locstuff.cpp', 'mode': '100644', 'type': 'blob', 'sha': '62fc8bb0aae433cca0dbeedff9c18a1f20738f64', 'size': 3871, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/62fc8bb0aae433cca0dbeedff9c18a1f20738f64'}, {'path': 'loc/locstuff.h', 'mode': '100644', 'type': 'blob', 'sha': '4cf455c8d2005dc18fc53f193cb22042aaa60106', 'size': 465, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/4cf455c8d2005dc18fc53f193cb22042aaa60106'}, {'path': 'main.cpp', 'mode': '100644', 'type': 'blob', 'sha': '3fa45528275778997594c0e5c1817fc9dfbfee2a', 'size': 452, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/3fa45528275778997594c0e5c1817fc9dfbfee2a'}, {'path': 'mainwindow.cpp', 'mode': '100644', 'type': 'blob', 'sha': '056ceb1abca85e4769e80200cf269f57048e4753', 'size': 11866, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/056ceb1abca85e4769e80200cf269f57048e4753'}, {'path': 'mainwindow.h', 'mode': '100644', 'type': 'blob', 'sha': '132584a3dd1de44236fa383af2de613b27fd38eb', 'size': 1096, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/132584a3dd1de44236fa383af2de613b27fd38eb'}, {'path': 'mainwindow.ui', 'mode': '100644', 'type': 'blob', 'sha': '57bbcd0daea1c76cce6e4d5e4d4f53bf76bd8f28', 'size': 6836, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/57bbcd0daea1c76cce6e4d5e4d4f53bf76bd8f28'}, {'path': 'parser.cpp', 'mode': '100644', 'type': 'blob', 'sha': '27f5ae48dda88ee25a3dd7fac990137c7c2472c3', 'size': 556, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/27f5ae48dda88ee25a3dd7fac990137c7c2472c3'}, {'path': 'parser.h', 'mode': '100644', 'type': 'blob', 'sha': '88f52653281e8ae73c6138876ac0b80420d25183', 'size': 147, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/88f52653281e8ae73c6138876ac0b80420d25183'}, {'path': 'sharedassets0.qrc', 'mode': '100644', 'type': 'blob', 'sha': 'c8d60a54e1d1d2b844b97b6bfb7c370eb6cef60c', 'size': 100, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/c8d60a54e1d1d2b844b97b6bfb7c370eb6cef60c'}, {'path': 'taskbaricon.png', 'mode': '100644', 'type': 'blob', 'sha': '270419c1209cd3a1754efc23efc4767bcd9d153a', 'size': 26305, 'url': 'https://api.github.com/repos/Muha0644/kadaif/git/blobs/270419c1209cd3a1754efc23efc4767bcd9d153a'}], 'truncated': False},
  'repo_data': ['cmake_minimum_required(VERSION 3.5)\n\nproject(kadaif VERSION 0.1 LANGUAGES CXX)\n\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\nset(CMAKE_AUTOUIC ON)\nset(CMAKE_AUTOMOC ON)\nset(CMAKE_AUTORCC ON)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(QT_FEATURE_intelcet ON)\n\nfind_package(QT NAMES Qt6 COMPONENTS Widgets Gui Core REQUIRED)\nfind_package(Qt${QT_VERSION_MAJOR} COMPONENTS Widgets REQUIRED)\n\nset(PROJECT_SOURCES\n\t\t\t\tmain.cpp\n\t\t\t\tconfig.h\n\t\t\t\tmainwindow.h mainwindow.cpp mainwindow.ui\n\t\t\t\tparser.h parser.cpp\n\t\t\t\tdataclass.h dataclass.cpp\n\t\t\t\tloc/locstuff.h loc/locstuff.cpp\n\t\t\t\tloc/loceditor.h loc/loceditor.cpp loc/loceditor.ui\n\t\t\t\tgfx/gfxstuff.h gfx/gfxstuff.cpp\n\t\t\t\tgfx/gfxeditor.h gfx/gfxeditor.cpp gfx/gfxeditor.ui\n\t\t\t\tsharedassets0.qrc\n)\n\nif(${QT_VERSION_MAJOR} GREATER_EQUAL 6)\n    qt_add_executable(kadaif\n        MANUAL_FINALIZATION\n        ${PROJECT_SOURCES}\n    )\n\nelse()\n    add_executable(kadaif\n    ${PROJECT_SOURCES}\n    )\nendif()\n\ntarget_link_libraries(kadaif PRIVATE Qt6::Gui Qt6::Core Qt${QT_VERSION_MAJOR}::Widgets)\n\n#eww osx\n#set_target_properties(kadaif PROPERTIES\n#    MACOSX_BUNDLE_GUI_IDENTIFIER my.example.com\n#    MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}\n#    MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}\n#)\n\nif(QT_VERSION_MAJOR EQUAL 6)\n    qt_finalize_executable(kadaif)\nendif()\n', '#pragma once\n/* This is a configuration file (duh)\n * You can read what each line does, and if you\n * want to enable or diable the feature, just\n * remove the comment and recompile kadaif.\n */\n\n// Removes the "title" when editing a file. By "title" I mean the name of the file being edited.\n#define NO_TITLE false\n\n// Makes the dynamic button panel look cooler. Disabled by default as it depends on wether you are\n// using a light or dark theme. The default is a lame flat panel.\n#define COOL_PANEL true\n\n// do not enable under any circumstance\n//#define KAWAII\n\n// Adds more BASS youtu.be/bZWzm3aFhTU\n//#define MANGOONAFORK\n\n// Optimize code for rendering pixelart. Use bilinear filtering when disabled.\n#define PIXELART true\n\n// Maximum size of images when zooming in/out\n#define MAX_SCALE 5.0\n#define MIN_SCALE 0.2\n\n// Relative amount to zoom in/out by for each step\n#define SCALE_FACTOR 1.25\n\n// What to use for EOL. "\\n" for LF, "\\r\\n" for CRLF.\n// Default is CRLF because most people use windows (sadly) and don\'t know what this means.\n#define NEWLINE "\\r\\n"\n\n// What fonts do you want to use. I could have made it editable without recompiling, but i chose not to.\n// Qt will try to find the closest match if an exact one can\'t be found.\n#define FONT_SERIF "Courier"\n#define FONT_SANS "sans-serif"\n', '#include "dataclass.h"\n\ndataClass& dataClass::getReference(){\n\tstatic dataClass instance;\n\treturn instance;\n};\n\ndataClass::dataClass(QObject *parent): QObject(parent){\n\tlocAll = nullptr;\n\tgfxAll = nullptr;\n}\n\ndataClass::~dataClass(){\n\tdelete locAll;\n\tdelete gfxAll;\n}\n\nvoid messHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg){\n\tQByteArray localMsg = msg.toLocal8Bit();\n\tconst char *file = context.file ? context.file : "";\n\tconst char *function = context.function ? context.function : "";\n\tswitch (type) {\n\t\tcase QtDebugMsg:\t//not for release\n\t\t\tfprintf(stdout, "[ Debug ]: (%s:%u, %s)\\n%s\\n", file, context.line, function, localMsg.constData());\n\t\t\tbreak;\n\n\t\tcase QtInfoMsg:\t\t//Something that does not directly cause issues: parsing errors,\n\t\t\tfprintf(stderr, "Info: %s (%s:%u, %s)\\n", localMsg.constData(), file, context.line, function);\n\t\t\tbreak;\n\n\t\tcase QtWarningMsg:{\t//Something that the user should be warned about: duplicate loc entry,\n\t\t\t//fprintf(stderr, "Warning: %s (%s:%u, %s)\\n", localMsg.constData(), file, context.line, function);\n\t\t\tbreak;}\n\n\t\tcase QtCriticalMsg:{\t//A big problem, with an error popup: file can\'t be opened,\n\t\t\tfprintf(stderr, "Critical: %s (%s:%u, %s)\\n", localMsg.constData(), file, context.line, function);\n\t\t\tQMessageBox errBox;\n\t\t\terrBox.setIcon(QMessageBox::Critical);\n\t\t\terrBox.setText("Critical error:");\n\t\t\terrBox.setInformativeText(localMsg.constData());\n\t\t\terrBox.exec();\n\t\t\tbreak;}\n\n\t\tcase QtFatalMsg:\t//most likely SEGFAULT lol\n\t\t\tfprintf(stderr, "[ Fatal ]: (%s:%u, %s)\\n %s\\n", file, context.line, function, localMsg.constData());\n\t\t\tbreak;\n\t}\n\n\tfflush(stdout);\n}\n', '#pragma once\n#include "config.h"\n#include <loc/locstuff.h>\n/*#include <gfx/gfxstuff.h>\n * this breaks everything, so i will just manually declare the gfxEntry struct\n */\nstruct gfxEntry{\n\tQString file;\t//path to the file this entry is from (omits "interface/")\n\tint line;\t\t//index 0 is file header\n\tQString key;\t//empty key means section header/long comment\n\tQString texturepath;\n};\n#include <QHash>\n#include <QString>\n#include <QObject>\n#include <QList>\n#include <stdio.h>\n#include <stdlib.h>\n\nclass dataClass: public QObject{ //my first singleton :)\n\tQ_OBJECT\n\npublic:\n\tstatic dataClass& getReference();\n\n\tQHash<QString, locEntry>* locAll;\n\tQHash<QString, gfxEntry>* gfxAll;\n\nprivate:\n\texplicit dataClass(QObject *parent = nullptr);\n\t~dataClass();\n\nsignals:\n\n};\n\nvoid messHandler(QtMsgType type, const QMessageLogContext &context, const QString &msg);\n', '/****************************************************************************\n**\n** Copyright (C) 2016 The Qt Company Ltd.\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the examples of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** BSD License Usage\n** Alternatively, you may use this file under the terms of the BSD license\n** as follows:\n**\n** "Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of The Qt Company Ltd nor the names of its\n**     contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include <QtWidgets>\n#include "flowlayout.h"\n\n\nFlowLayout::FlowLayout(QWidget *parent, int margin, int hSpacing, int vSpacing):\nQLayout(parent), m_hSpace(hSpacing), m_vSpace(vSpacing){\n\tsetContentsMargins(margin, margin, margin, margin);\n}\n\nFlowLayout::FlowLayout(int margin, int hSpacing, int vSpacing): m_hSpace(hSpacing), m_vSpace(vSpacing){\n\tsetContentsMargins(margin, margin, margin, margin);\n}\n\nFlowLayout::~FlowLayout(){\n\tQLayoutItem *item;\n\twhile ((item = takeAt(0)))\n\t\tdelete item;\n}\n\nvoid FlowLayout::addItem(QLayoutItem *item){\n\titemList.append(item);\n}\n\nint FlowLayout::horizontalSpacing() const{\n\tif (m_hSpace >= 0) {\n\t\treturn m_hSpace;\n\t} else {\n\t\treturn smartSpacing(QStyle::PM_LayoutHorizontalSpacing);\n\t}\n}\n\nint FlowLayout::verticalSpacing() const{\n\tif (m_vSpace >= 0) {\n\t\treturn m_vSpace;\n\t} else {\n\t\treturn smartSpacing(QStyle::PM_LayoutVerticalSpacing);\n\t}\n}\n\nint FlowLayout::count() const{\n\treturn itemList.size();\n}\n\nQLayoutItem *FlowLayout::itemAt(int index) const{\n\treturn itemList.value(index);\n}\n\nQLayoutItem *FlowLayout::takeAt(int index){\n\tif (index >= 0 && index < itemList.size())\n\t\treturn itemList.takeAt(index);\n\treturn nullptr;\n}\n\nQt::Orientations FlowLayout::expandingDirections() const{\n\treturn { };\n}\n\nbool FlowLayout::hasHeightForWidth() const{\n\treturn true;\n}\n\nint FlowLayout::heightForWidth(int width) const{\n\tint height = doLayout(QRect(0, 0, width, 0), true);\n\treturn height;\n}\n\nvoid FlowLayout::setGeometry(const QRect &rect){\n\tQLayout::setGeometry(rect);\n\tdoLayout(rect, false);\n}\n\nQSize FlowLayout::sizeHint() const{\n\treturn minimumSize();\n}\n\nQSize FlowLayout::minimumSize() const{\n\tQSize size;\n\tfor (const QLayoutItem *item : qAsConst(itemList))\n\t\tsize = size.expandedTo(item->minimumSize());\n\n\tconst QMargins margins = contentsMargins();\n\tsize += QSize(margins.left() + margins.right(), margins.top() + margins.bottom());\n\treturn size;\n}\n\nint FlowLayout::doLayout(const QRect &rect, bool testOnly) const{\n\tint left, top, right, bottom;\n\tgetContentsMargins(&left, &top, &right, &bottom);\n\tQRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);\n\tint x = effectiveRect.x();\n\tint y = effectiveRect.y();\n\tint lineHeight = 0;\n\n\n\tfor (QLayoutItem *item : qAsConst(itemList)) {\n\t\tconst QWidget *wid = item->widget();\n\t\tint spaceX = horizontalSpacing();\n\t\tif (spaceX == -1)\n\t\t\tspaceX = wid->style()->layoutSpacing(\n\t\t\t\tQSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);\n\t\tint spaceY = verticalSpacing();\n\t\tif (spaceY == -1)\n\t\t\tspaceY = wid->style()->layoutSpacing(\n\t\t\t\tQSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);\n\n\t\tint nextX = x + item->sizeHint().width() + spaceX;\n\t\tif (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {\n\t\t\tx = effectiveRect.x();\n\t\t\ty = y + lineHeight + spaceY;\n\t\t\tnextX = x + item->sizeHint().width() + spaceX;\n\t\t\tlineHeight = 0;\n\t\t}\n\n\t\tif (!testOnly)\n\t\t\titem->setGeometry(QRect(QPoint(x, y), item->sizeHint()));\n\n\t\tx = nextX;\n\t\tlineHeight = qMax(lineHeight, item->sizeHint().height());\n\t}\n\treturn y + lineHeight - rect.y() + bottom;\n}\n\nint FlowLayout::smartSpacing(QStyle::PixelMetric pm) const{\n\tQObject *parent = this->parent();\n\tif (!parent) {\n\t\treturn -1;\n\t} else if (parent->isWidgetType()) {\n\t\tQWidget *pw = static_cast<QWidget *>(parent);\n\t\treturn pw->style()->pixelMetric(pm, nullptr, pw);\n\t} else {\n\t\treturn static_cast<QLayout *>(parent)->spacing();\n\t}\n}\n\n', '/****************************************************************************\n**\n** Copyright (C) 2016 The Qt Company Ltd.\n** Contact: https://www.qt.io/licensing/\n**\n** This file is part of the examples of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and The Qt Company. For licensing terms\n** and conditions see https://www.qt.io/terms-conditions. For further\n** information use the contact form at https://www.qt.io/contact-us.\n**\n** BSD License Usage\n** Alternatively, you may use this file under the terms of the BSD license\n** as follows:\n**\n** "Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of The Qt Company Ltd nor the names of its\n**     contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#pragma once\n\n#include <QLayout>\n#include <QRect>\n#include <QStyle>\n\nclass FlowLayout: public QLayout{\npublic:\n\texplicit FlowLayout(QWidget *parent, int margin = -1, int hSpacing = -1, int vSpacing = -1);\n\texplicit FlowLayout(int margin = -1, int hSpacing = -1, int vSpacing = -1);\n\t~FlowLayout();\n\n\tvoid addItem(QLayoutItem *item) override;\n\tint horizontalSpacing() const;\n\tint verticalSpacing() const;\n\tQt::Orientations expandingDirections() const override;\n\tbool hasHeightForWidth() const override;\n\tint heightForWidth(int) const override;\n\tint count() const override;\n\tQLayoutItem *itemAt(int index) const override;\n\tQSize minimumSize() const override;\n\tvoid setGeometry(const QRect &rect) override;\n\tQSize sizeHint() const override;\n\tQLayoutItem *takeAt(int index) override;\n\nprivate:\n\tint doLayout(const QRect &rect, bool testOnly) const;\n\tint smartSpacing(QStyle::PixelMetric pm) const;\n\n\tQList<QLayoutItem *> itemList;\n\tint m_hSpace;\n\tint m_vSpace;\n};\n', '#include "gfxeditor.h"\n#include "ui_gfxeditor.h"\n#include "gfxstuff.h"\n\n\ngfxeditor::gfxeditor(const gfxEntry &entry, QWidget *parent): QDialog(parent), ui(new Ui::gfxeditor), entry{entry}{\n\tui->setupUi(this);\n\tQSettings settings("muha0644","Kadaif");\n\trestoreGeometry(settings.value("gfxedit/geometry").toByteArray());\n\n\tpngvju = new PngView(pngify(entry.texturepath));\n\tui->preview->addWidget(pngvju);\n\n\tQFont font(FONT_SERIF, 11);\n\tfont.setFixedPitch(false);\n\n\tui->nameEdit->setFont(font);\n\tui->nameEdit->setText(entry.key);\n\tui->texturefileEdit->setFont(font);\n\tui->texturefileEdit->setText(entry.texturepath);\n\n\tsetWindowTitle(entry.key);\n}\n\ngfxeditor::~gfxeditor(){\n\tQSettings settings("muha0644","Kadaif");\n\tsettings.setValue("gfxedit/geometry", saveGeometry());\n\tdelete ui;\n}\n\nvoid gfxeditor::on_nameEdit_textEdited(const QString &arg1){\n\tif(windowTitle() == ("* " + arg1)) return;\n\tsetWindowTitle("* " + arg1);\n}\nvoid gfxeditor::on_texturefileEdit_textEdited(const QString &arg1){\n\t//pngvju->change(arg1);\t//...remaking the WHOLE FUCKING OBJECT BECAUSE\n\t//CHANGING THE FUCKING IMAGE DOESN\'T WORK!\n\t//WHY DOESN\'T IT WANT TO WORK, I CAN MAKE ELIPSES BUT NOT PIXMAPS\n\tdelete pngvju;\n\tpngvju = new PngView(pngify(arg1));\n\tui->preview->addWidget(pngvju);\n\n\tif(windowTitle().startsWith("*")) return;\n\tsetWindowTitle("* " + windowTitle());\n}\n\nvoid gfxeditor::on_Save_released(){\n\tif(ui->nameEdit->text().contains(" ")){\n\t\tqCritical() << "GFX name cannot contain spaces: " << ui->nameEdit->text();\n\t\treturn;\n\t}\n\tgfxEntry newEntry;\n\tnewEntry.file = entry.file;\n\tnewEntry.line = entry.line;\n\tnewEntry.texturepath = ui->texturefileEdit->text();\n\tnewEntry.key = ui->nameEdit->text();\n\tsaveAGfxEntry(newEntry, entry);\n\temit saved();\n\tclose();\n}\n\nvoid gfxeditor::on_FileDialogue_released(){\n\tQSettings settings;\n\tQString absPath = QDir::currentPath();\n\tQString fileName = QFileDialog::getOpenFileName(this,"Select Texture for " + ui->nameEdit->text(),\n\t\t\t\t\t\tabsPath, "Image Files (*.png *.jpg *.bmp *.dds *.tga)");\n\tif(fileName.isEmpty()) return;\n\tui->texturefileEdit->setText(fileName.remove(absPath+"/"));\n\tthis->on_texturefileEdit_textEdited(fileName);\n}\n\n', '#pragma once\n#include <QDialog>\n#include "gfxstuff.h"\n\nnamespace Ui {\n\tclass gfxeditor;\n}\n\nclass gfxeditor : public QDialog{\n\tQ_OBJECT\n\n\tpublic:\n\texplicit gfxeditor(const gfxEntry &entry,QWidget *parent = nullptr);\n\t~gfxeditor();\n\n\tprivate slots:\n\tvoid on_nameEdit_textEdited(const QString &arg1);\n\tvoid on_texturefileEdit_textEdited(const QString &arg1);\n\tvoid on_Save_released();\n\tvoid on_FileDialogue_released();\n\n\tsignals:\n\tvoid saved();\n\n\n\tprivate:\n\tPngView* pngvju;\n\tgfxEntry entry;\n\tUi::gfxeditor *ui;\n};\n\n', '#include "gfx/gfxstuff.h"\n#include "config.h"\n#include "gfx/gfxeditor.h"\n#include <QDirIterator>\n#include <QScrollArea>\n#include <QFile>\n#include <QProcess>\n\nvoid loadGfxFile(QHash<QString, gfxEntry>* gfxAll, QString &filepath){\t//loads only one gfx file\n\tQFile file(filepath);\n\tint liNo = 0;\n\tif(!file.open(QIODevice::ReadOnly | QIODevice::Text)){\n\t\tqCritical() << "Failed to open gfx file" << filepath.remove("./interface/") << ":" <<file.errorString();\n\t\treturn;\n\t}\n\tQTextStream in(&file);\n\tQString line = "#";\n\twhile(line.startsWith("#") || (line.trimmed() == "")){\n\t\tline = in.readLine().trimmed(); liNo++;\n\t}\n\tif(!line.startsWith("spriteTypes = {")){\n\t\tqInfo() << "Parsing error in file " + filepath + ". This is not a valid gfx file.";\n\t\treturn;\n\t}\n\n\tgfxEntry* entry = nullptr;\n\tbool isSpriteType = false;\n\twhile(!in.atEnd()){\t\t//reflective comment: damn i used to suck at programming...\n\t\tline = in.readLine().trimmed(); liNo++;\n\t\twhile(line.startsWith("#") || line.trimmed() == ""){ //skip comments\n\t\t\tline = in.readLine().trimmed(); liNo++;\n\t\t}\n\t\tline = line.section("#",0,0);\t//ignore inline comments\n\t\tif(isSpriteType){\t//are you inside the nested brackets (IE. inside spriteTypes = {...} ) rn?\n\t\t\tif(line.startsWith("name = ", Qt::CaseInsensitive)){\n\t\t\t\tif(line.count(\'"\') != 2){\n\t\t\t\t\tqInfo() << "Invalid (empty) spriteType name in " + entry->file + ", line " + QString::number(liNo);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tentry->key = line.section(\'"\', 1).remove(\'"\');\n\t\t\t} else if(line.startsWith("texturefile = ", Qt::CaseInsensitive)){\n\t\t\t\tif(line.count(\'"\') != 2){\n\t\t\t\t\tqInfo() << "Invalid (empty) filepath in " + entry->file + ", line " + QString::number(liNo);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tentry->texturepath = line.section(\'"\', 1).remove(\'"\');\n\t\t\t} else if(line.startsWith("}")){ //sprite has been declared correctly\n\t\t\t\tisSpriteType = false;\n\t\t\t\tif(gfxAll->contains(entry->key)){\t//duplicate check\n\t\t\t\t\tQString mesg("Duplicate key found: " + entry->key + "\\n" + entry->file + " on line: " + QString::number(entry->line) + "\\n"\n\t\t\t\t\t\t\t+ gfxAll->value(entry->key).file + " on line: "  + QString::number(gfxAll->value(entry->key).line));\n\t\t\t\t\tqWarning() << mesg;\n\t\t\t\t\tQSettings settings("muha0644", "Kadaif");\n\t\t\t\t\tsettings.setValue("gfxDup", settings.value("gfxDup").toString() + mesg + "\\n\\n");\n\t\t\t\t}\n\t\t\t\tgfxAll->insert(entry->key, *entry);\n\t\t\t\tdelete entry;\t\t\t\t\t\t\t//wait what?? Apparently it works...\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tQList<QString> valid = {"legacy_lazy_load", "allwaystransparent", "transparencecheck", "effectFile", "noOfFrames"};\n\t\t\t\tif(valid.contains(line.first(line.indexOf("=")).trimmed(), Qt::CaseInsensitive)) continue;\n\t\t\t\tif(line.startsWith("animation = {")){\n\t\t\t\t\twhile(!line.startsWith("}")){\n\t\t\t\t\t\tline = in.readLine().trimmed(); liNo++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tqInfo() << "Parsing error in file " + filepath + ": unexpected line in SpriteType decleration on line " + QString::number(liNo);\n\t\t\t}\n\t\t} else {//expecting sprite decleration or clsoing brackets\n\t\t\tif(line.startsWith("spriteType = {", Qt::CaseInsensitive)){\n\t\t\t\tentry = new gfxEntry;\n\t\t\t\tentry->line = liNo;\n\t\t\t\tentry->file = filepath.remove("./interface/");\n\t\t\t\tisSpriteType = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(line.startsWith("}")) break;\t//file about to end\n\t\t\t//qInfo() << "Parsing error in file " + filepath + ": expected SpriteType decleration or \'}\' on line " + QString::number(liNo);\n\t\t}\n\t}\n}\n\nQHash<QString, gfxEntry>* loadGfx(){\t//loads all the gfx\n\tQHash<QString, gfxEntry>* gfxAll = new QHash<QString, gfxEntry>;\n\tQSettings settings("muha0644", "Kadaif");\n\tsettings.setValue("gfxDup", "");\n\n\tQDir gfxDir(".");\n\tif(!gfxDir.cd("interface")){\t\t//what if it doesn\'t exist?\n\t\tif(!gfxDir.mkdir("interface")){\n\t\t\tqCritical() << "Failed to create \\"interface\\" folder. Something is seriously wrong.";\n\t\t\tdelete gfxAll; //abortus\n\t\t\treturn new QHash<QString, gfxEntry>; //don\'t return nullptr\n\t\t}\n\t\tgfxDir.cd("interface");\n\t}\n\n\tQDirIterator iter("./interface", {"*.gfx"}, QDir::Files ,QDirIterator::Subdirectories);\n\twhile(iter.hasNext()){\n\t\tQString filepath = iter.next();\n\t\tloadGfxFile(gfxAll, filepath);\n\t}\n\treturn gfxAll;\n}\n\ngfxWidget::gfxWidget(QString &path, QObject* parent){\n\tQVBoxLayout *vLayout = new QVBoxLayout(this);\n\tQHBoxLayout *buttonBar = new QHBoxLayout;\n\tQPushButton *editButt = new QPushButton("Edit");\n\tQPushButton *newButt = new QPushButton("New GFX entry");\n\tQPushButton *deleteButt = new QPushButton("Delete selection");\n\tQSpacerItem *spase = new QSpacerItem(10000,20,QSizePolicy::Preferred);\n#if !NO_TITLE\n\tvLayout->setContentsMargins(5, 2, 0, 0);\n\tQLabel *title = new QLabel(path);\n\tQFont font(FONT_SANS, 12, QFont::Bold);\n\ttitle->setFont(font);\n\tvLayout->addWidget(title);\n#endif\n\n\tgfxList = new QListWidget();\n\tconnect(newButt, &QPushButton::clicked, this, &gfxWidget::newthis);\n\tconnect(deleteButt, &QPushButton::clicked, this, &gfxWidget::deletethis);\n\tconnect(editButt, &QPushButton::clicked, this, &gfxWidget::edit);\n\tconnect(gfxList, &QListWidget::itemDoubleClicked, this, &gfxWidget::edit);\n\tbuttonBar->addWidget(newButt);\n\tbuttonBar->addWidget(deleteButt);\n\tbuttonBar->addWidget(editButt);\n\tbuttonBar->addSpacerItem(spase);\n\n\tcurPath = path;\n\trefreshList();\n\tvLayout->addLayout(buttonBar);\n\tvLayout->addWidget(gfxList);\n}\ngfxWidget::~gfxWidget(){\n\tdelete gfxList;\n}\n\nvoid gfxWidget::refreshList(){\n\tgfxList->clear();\n\tloadGfxEntries(gfxList, curPath);\n}\n\nvoid gfxWidget::edit(){\n\tif(gfxList->currentRow() == -1) return;\n\tgfxeditor *gfxEditW = new gfxeditor(liveDB.gfxAll->value(gfxList->currentItem()->text()));\n\tgfxEditW->setAttribute(Qt::WA_DeleteOnClose);\n\tgfxEditW->setAttribute( Qt::WA_QuitOnClose, false);\n\tgfxEditW->show();\n\tconnect(gfxEditW, &gfxeditor::saved, this, &gfxWidget::refreshList);\n}\nvoid gfxWidget::deletethis(){\n\tif(gfxList->currentRow() == -1) return;//-1 means nothing is selected\n\tdeleteAGfxEntry(liveDB.gfxAll->value(gfxList->currentItem()->text()));\n\trefreshList(); //usually editor calls this\n}\nvoid gfxWidget::newthis(){\n\tgfxList->insertItem(gfxList->currentRow()+1, " ");\n\tgfxEntry newEntry;\n\tnewEntry.file = curPath.sliced(sizeof("interface")); //should find a better way of doing this...\n\tnewEntry.line = -(liveDB.gfxAll->value(gfxList->currentItem()->text())).line; //negative number means insert new entry after that line\n\tgfxList->setCurrentRow(gfxList->currentRow()+1);\n\n\tgfxeditor *gfxEditW = new gfxeditor(liveDB.gfxAll->insert(" ", newEntry).value());\n\tgfxEditW->setAttribute(Qt::WA_DeleteOnClose);\n\tgfxEditW->setAttribute( Qt::WA_QuitOnClose, false);\n\tgfxEditW->show();\n\tconnect(gfxEditW, &gfxeditor::saved, this, &gfxWidget::refreshList);\n}\nvoid gfxWidget::dup(){\n\tQSettings settings("muha0644", "Kadaif");\n\tQMessageBox msgBox;\n\tmsgBox.setText("Duplicate gfx entries:");\n\tmsgBox.setInformativeText(settings.value("gfxDup").toString());\n\tmsgBox.exec();\n}\nvoid gfxWidget::empty(){\n\tQString empty;\n\tforeach(auto entry, liveDB.gfxAll->values()){\n\t\tif(entry.texturepath.trimmed().isEmpty()){\n\t\t\tempty.append("Empty entry found: " + entry.key + "\\nin " + entry.file + " near line " + QString::number(entry.line) + "\\n\\n");\n\t\t};\n\t}\n\tQMessageBox msgBox;\n\tmsgBox.setText("Empty gfx entries:");\n\tmsgBox.setInformativeText(empty);\n\tmsgBox.exec();\n}\n\nvoid loadGfxEntries(QListWidget *content, QString &path){\t//loads entires from file into a list with icons. Should be a method of gfxWidget but whatever...\n\tQHash<QString, gfxEntry>* gfxEntries = new QHash<QString, gfxEntry>;\n\tloadGfxFile(gfxEntries, path);\n\n\tQHashIterator<QString, gfxEntry> iter(*gfxEntries);\n\tQMap<int, gfxEntry> sorted;\n\twhile(iter.hasNext()){\n\t\tgfxEntry entry = iter.next().value();\n\t\tsorted.insert(entry.line, entry);\n\t}\n\tdelete gfxEntries;\n\n\tQMap<int, gfxEntry>::const_iterator i = sorted.constBegin();\t//trying out STL-style iterator, instead of java-style\n\twhile (i != sorted.constEnd()) {\n\t\tgfxEntry entry = i.value();\n\t\t//open the .dds with OIIO and export it to png into a temp dir\n\t\t//you don\'t need to hear the rant i put here before...\n\t\t//tl;dr Qt had .dds support before, now it doesn\'t.\n\t\tQString pngpath = pngify(entry.texturepath);\n\t\tif(pngpath == "")  qInfo() << "Texture file" << entry.texturepath << "defined near" << entry.file+":"+QString::number(entry.line) << "does not exist.";\n\t\tcontent->addItem(new QListWidgetItem(QIcon(QPixmap(pngpath)), entry.key));\n\t\t++i;\n\t}// Conclusion: java-style iterators are slower but nicer.\n}\n\nvoid saveAGfxEntry(const gfxEntry &newEntry, const gfxEntry &oldEntry){\t//this approach is a bit more surgical than the loc code\n\tQFile file("interface/" + newEntry.file);\n\tif (!file.open(QIODevice::ReadOnly | QIODevice::Text)){\n\t\tqCritical() << "Failed to open gfx file" << newEntry.file << "for reading";\n\t\treturn;\n\t}\n\n\tQString line, buffer;\n\tQTextStream stream(&file);\n\tif(oldEntry.line > 0){ // negative number means add new entry\n\t\tfor(int i = 0; i < oldEntry.line; i++){\t// skip to the important part\n\t\t\tbuffer.append(stream.readLine()+NEWLINE);\n\t\t}// should be at the line with "spriteType = {"\n\t\twhile(!line.contains("}")){// loop until the end of the entry\n\t\t\tstream.readLineInto(&line);\n\t\t\tif(line.trimmed().startsWith("name = ", Qt::CaseInsensitive)){\n\t\t\t\tline.replace(oldEntry.key, newEntry.key);\n\t\t\t} else if(line.trimmed().startsWith("texturefile = ", Qt::CaseInsensitive)){\n\t\t\t\tline.replace(oldEntry.texturepath, newEntry.texturepath);\n\t\t\t}\n\t\t\tbuffer.append(line+NEWLINE);\n\t\t}\n\t\twhile(!stream.atEnd()){//found and replaced the important part, finish buffering the file\n\t\t\tbuffer.append(stream.readLine()+NEWLINE);\n\t\t}\n\t} else { //adding a new entry to the end.\n\t\tfor(int i = 1; i < -oldEntry.line; i++) buffer.append(stream.readLine()+NEWLINE);\n\t\tbuffer.append("\\tspriteType = {" NEWLINE); //do not question why this works. It does.\n\t\tbuffer.append("\\t\\tname = \\"" + newEntry.key + "\\"" NEWLINE);\n\t\tbuffer.append("\\t\\ttexturefile = \\"" + newEntry.texturepath + "\\"" NEWLINE);\n\t\tbuffer.append("\\t}" NEWLINE);\n\t\twhile(!stream.atEnd()) buffer.append(stream.readLine()+NEWLINE);\n\t}\n\n\tfile.close();\t\t\t//write buffer to stream\n\tfile.open(QIODevice::WriteOnly | QIODevice::Text);\n\tfile.write(buffer.toUtf8());\n\tfile.close();\t\t\t//since we know what entry was changed, no need to reload the entire database\n\tdataClass &liveDB = dataClass::getReference();\n\tliveDB.gfxAll->remove(oldEntry.key);\n\tliveDB.gfxAll->insert(newEntry.key, newEntry);\n}\n\nvoid deleteAGfxEntry(const gfxEntry& entry){\n\tQFile file("interface/" + entry.file);\n\tif (!file.open(QIODevice::ReadOnly | QIODevice::Text)){\n\t\tqCritical() << "Failed to open gfx file" << entry.file << "for reading & writing.";\n\t\treturn;\n\t}\n\tQString line, buffer;\n\tQTextStream stream(&file);\n\n\tfor(int i = 1; i < entry.line; i++){\n\t\tbuffer.append(stream.readLine()+NEWLINE);\n\t}// should be before the line with "spriteType = {"\n\twhile(!line.contains("}")) stream.readLineInto(&line);//not writing the entry to be deleted into the buffer\n\twhile(!stream.atEnd()) buffer.append(stream.readLine()+NEWLINE);\n\n\tfile.close();\t\t\t//opening with r+w is buggy for some reason, so i have to open the file two times\n\tfile.open(QIODevice::WriteOnly | QIODevice::Text); file.write(buffer.toUtf8()); file.close();\n\tdataClass &liveDB = dataClass::getReference();\n\tliveDB.gfxAll->remove(entry.key);\n}\n\nQString pngify(const QString& path){\n\tif(path.endsWith(".png")) return path;\n\tQString ddspath = "./" + path;\n\tQString tmppath = "./"  + path + ".png";\n\n\tif(QFile::exists(tmppath)){\n\t\tif(QFileInfo(ddspath).lastModified() < QFileInfo(tmppath).lastModified()){\n\t\t\treturn tmppath;\n\t\t}\n\t} else {\n\t\tQFileInfo file(tmppath);\n\t\tQDir dir;\n\t\tdir.mkpath(file.dir().path());\n\t}\n\tif(!path.isEmpty() && QFileInfo(ddspath).isFile()){\n\t\tQProcess::execute("magick", {ddspath, tmppath});\n\t} else return "";\n\treturn tmppath;\n}\n\nPngView::PngView(const QString& pngPath, QWidget *parent): QGraphicsView(parent){\n\tsetDragMode(QGraphicsView::ScrollHandDrag);\n\n\tscene = new QGraphicsScene;\n\titem = scene->addPixmap(QPixmap(pngPath));//new QGraphicsPixmapItem(QPixmap(pngPath));\n\t//at least i\'m not heap allocating... easier to delete...\n#if !PIXELART\n\titem->setTransformationMode(Qt::SmoothTransformation);\n#endif\n\tsetScene(scene);\n}\nvoid PngView::change(const QString& pngPath){//does not work. will not work. will not try to make it work.\n\t//jusit remake the whole thing, it\'s faster and easier.\n\tscene->clear();\n\tQPixmap *mm = new QPixmap(pngPath);\n\titem = scene->addPixmap(*mm);\n#if !PIXELART\n\titem->setTransformationMode(Qt::SmoothTransformation);\n#endif\n\tscene->update();\n}\nvoid PngView::wheelEvent(QWheelEvent *event){\n\tfloat scaleRN = transform().m11();\n\tif(event->angleDelta().y() > 0 ){\n\t  if(scaleRN < MAX_SCALE)   scale(SCALE_FACTOR, SCALE_FACTOR);\n\t}\n\telse{\n\t\tif(scaleRN > MIN_SCALE) scale(1/SCALE_FACTOR, 1/SCALE_FACTOR);\n\t}\n}\n', '#pragma once\n#include "dataclass.h"\n#include <QString>\n#include <QWidget>\n#include <QListWidget>\n#include <QVBoxLayout>\n#include <QHBoxLayout>\n#include <QPushButton>\n#include <QLabel>\n#include <QSettings>\n#include <QHash>\n#include <OpenImageIO/imageio.h>\n#include <QGraphicsView>\n#include <QGraphicsScene>\n#include <QGraphicsPixmapItem>\n#include <QWheelEvent>\n#include <QKeyEvent>\n\n/*struct gfxEntry{\n\tQString file;\t//path to the file this entry is from (omits "interface/")\n\tint line;\t\t//index 0 is file header\n\tQString key;\t//empty key means section header/long comment\n\tQString texturepath;\n};\n ^ defined in dataclass.h because of a broken cyclic dependency */\n\nvoid loadGfxFile(QHash<QString, gfxEntry>* gfxAll, QString &filepath);\nQHash<QString, gfxEntry>* loadGfx();\nvoid loadGfxEntries(QListWidget *content, QString &path);\nvoid saveAGfxEntry(const gfxEntry &newEntry, const gfxEntry &oldEntry);\nvoid deleteAGfxEntry(const gfxEntry &entry);\n\nQString pngify(const QString& path);\t//takes a path to a texture and returns the path of a temp png version (with refresh in mind), "" if path does not exist\n\nclass gfxWidget: public QWidget{\n\tQ_OBJECT\n\tpublic:\n\texplicit gfxWidget(QString &path, QObject *parent = nullptr);\n\t~gfxWidget();\n\n\tvoid edit();\n\tvoid deletethis();\t//new and delete already taken...\n\tvoid newthis();\n\tvoid dup();\n\tvoid empty();\n\n\tprivate:\n\tQString curPath;\n\tdataClass& liveDB = dataClass::getReference();\n\tQListWidget *gfxList;\n\n\tpublic slots:\n\tvoid refreshList();\n};\n\nclass PngView: public QGraphicsView{\n\tQ_OBJECT\n\tpublic:\n\texplicit PngView(const QString& pngPath, QWidget *parent = nullptr);\n\tvoid change(const QString& pngPath);\n\tQGraphicsScene* scene;\n\tQGraphicsPixmapItem* item;\n\n\tprotected Q_SLOTS:\n\tvoid wheelEvent(QWheelEvent *event);\n};\n', '#include "loceditor.h"\n#include "locstuff.h"\n#include "ui_loceditor.h"\n#include <QListWidget>\n\n//STILL NO WAY TO EDIT KEYS! --done\n//or a preview, which was my goal...\n\n/*locHighlighter::locHighlighter(QTextDocument* parent):QSyntaxHighlighter(parent){\n\tthis->isTool = 0;\n\tHighlightingRule rule;\n}\n\nlocHighlighter::locHighlighter():QSyntaxHighlighter(new QTextDocument){\t//sussy\n\tthis->isTool = 1;\n\tHighlightingRule rule;\n\n}\n\nvoid locHighlighter::highlightBlock(const QString& text){\n\n}*/\n\n\n\n/*void Dialog::setFont()\n{\n\tconst QFontDialog::FontDialogOptions options = QFlag(fontDialogOptionsWidget->value());\n\n\tconst QString &description = fontLabel->text();\n\tQFont defaultFont;\n\tif (!description.isEmpty())\n\t\tdefaultFont.fromString(description);\n\n\tbool ok;\n\tQFont font = QFontDialog::getFont(&ok, defaultFont, this, "Select Font", options);\n\tif (ok) {\n\t\tfontLabel->setText(font.key());\n\t\tfontLabel->setFont(font);\n\t}\n}\n\nvoid Dialog::setColor()\n{\n\tconst QColorDialog::ColorDialogOptions options = QFlag(colorDialogOptionsWidget->value());\n\tconst QColor color = QColorDialog::getColor(Qt::green, this, "Select Color", options);\n\n\tif (color.isValid()) {\n\t\tcolorLabel->setText(color.name());\n\t\tcolorLabel->setPalette(QPalette(color));\n\t\tcolorLabel->setAutoFillBackground(true);\n\t}\n}*/\n\nvoid locEditor::on_textEdit_textChanged(){\n\tif(windowTitle().startsWith("*")) return;\n\tsetWindowTitle("* " + windowTitle());\n}\n\nlocEditor::locEditor(QWidget *parent): QWidget(parent),\tui(new Ui::locEditor){\t\t//opened as tool\n\tQSettings settings("muha0644","Kadaif");\n\trestoreGeometry(settings.value("locedit/geometry").toByteArray());\n\tui->setupUi(this);\n\n\tQFont font(FONT_SERIF, 11);\n\tfont.setFixedPitch(false);\n\tui->textEdit->setFont(font);\n\n\t//locHigh = new locHighlighter(ui->textEdit->document());\n\tdelete ui->saveButton;\n\n\t//ui->textEdit->setPlainText();\n}\n\nlocEditor::locEditor(QListWidgetItem *item, QWidget *parent): QWidget(parent), ui(new Ui::locEditor){ //opened by double clicking an item\n\tQSettings settings("muha0644","Kadaif");\n\trestoreGeometry(settings.value("locedit/geometry").toByteArray());\n\tui->setupUi(this);\n\n\tQFont font(FONT_SERIF, 11);\n\tfont.setFixedPitch(false);\n\tui->textEdit->setFont(font);\n\n\t//locHigh = new locHighlighter(ui->textEdit->document());\t//don\'t have one yet\n\n\tentry.line = item->listWidget()->currentRow()+1;\n\tQString itemline = item->text();\n\tauto stuff = itemline.trimmed().split(QRegularExpression(":\\\\d "));\n\tif(stuff.size() != 2){\n\t\tui->textEdit->setPlainText(itemline.trimmed());\n\t\tsetWindowTitle("line "+QString::number(item->listWidget()->currentRow()+1));\n\t\tif(itemline.trimmed() == "" || itemline.trimmed().startsWith("#")){\n\n\t\t\treturn;\n\t\t}\n\t\tqInfo() << "Error parsing loc item:" << item->text() << ". Make sure there is only one \':0\' on this line";\n\t\treturn; //maybe an error popup?\n\t} else{\t\t\t//an actual entry has been found\n\t\tentry = liveDB.locAll->value(stuff[0]);\n\n\t\t//TODO: make it be nice maybe just add a preview window?\n\t\t//auto text = entry.value.split(\'"\',Qt::SkipEmptyParts);\n\t\t//if(text.size() == 0){\t//it\'s a comment... well not really, should look into this!\n\t\t\tui->textEdit->setPlainText(entry.value);\t//so the entry has " somewhere.\n\t\t//} else {\n\t\t\t//ui->textEdit->setPlainText(text[0]);\n\t\t//}\n\t\tsetWindowTitle(entry.key);\n\t}\n}\n\nlocEditor::~locEditor(){\n\tQSettings settings("muha0644","Kadaif");\n\tsettings.setValue("locedit/geometry", saveGeometry());\n\tdelete ui;\n}\n\nvoid locEditor::on_saveButton_clicked(){\t// new line is buggy\n\tentry.value = ui->textEdit->toPlainText();\n\tif(entry.file == ""){\n\t\treturn; //it should be copied to clipboard, but not now.\n\t}\n\tQSettings settings("muha0644","Kadaif");\n\tQString path = "localisation/" + entry.file;\n\n\tQList<QString> *loceList = parseLocFile(path);\n\tif(entry.key == ""){\n\t\tloceList->replace(entry.line-1, entry.value.startsWith(" ")? entry.value : " " + entry.value);\n\t} else {\n\t\tloceList->replace(entry.line-1, " " + entry.key + ":0 " + entry.value);\n\t}\n\tsaveLocFile(loceList, path);\n\n\tliveDB.locAll->insert(entry.key, entry);\n\tsetWindowTitle(entry.key);\n\temit saved(path);\n\tthis->destroy();\n\tdelete this->liveDB.locAll;\n\tthis->liveDB.locAll = loadLoc();\n}\n\n\nvoid locEditor::on_copyButton_clicked(){\n\tui->textEdit->selectAll();\n\tui->textEdit->copy();\n\tui->textEdit->moveCursor(QTextCursor::Start);\n}\n\n', '#pragma once\n#include <QSyntaxHighlighter>\n#include <QRegularExpression>\n#include <QTextCharFormat>\n#include <QTextDocument>\n#include <QWidget>\n#include <QList>\n#include "dataclass.h"\n#include <QListWidgetItem>\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {class locEditor;}\nQT_END_NAMESPACE\n\n/*class locHighlighter: public QSyntaxHighlighter{\n\tQ_OBJECT\n\n\tpublic:\n\texplicit locHighlighter(QTextDocument *parent);\n\tlocHighlighter();\n\n\tprotected:\n\tvoid highlightBlock(const QString &text) override;\n\n\tprivate:\n\tbool isTool;\n\tstruct HighlightingRule{\n\t\tQRegularExpression pattern;\n\t\tQTextCharFormat format;\n\t};\n\tQList<HighlightingRule> highlightingRules;\n\n\tQRegularExpression commentStartExpression;\n\tQRegularExpression commentEndExpression;\n\n\tQTextCharFormat keywordFormat;\n\tQTextCharFormat classFormat;\n\tQTextCharFormat singleLineCommentFormat;\n\tQTextCharFormat multiLineCommentFormat;\n\tQTextCharFormat quotationFormat;\n\tQTextCharFormat functionFormat;\n};*/\n\nclass locEditor : public QWidget{\n\tQ_OBJECT\n\n\tpublic:\n\tlocEditor(QWidget *parent = nullptr);\n\tlocEditor(QListWidgetItem *item, QWidget *parent = nullptr);\n\t~locEditor();\n\n\tlocEntry entry;\n\tdataClass& liveDB = dataClass::getReference();\n\n\tprivate slots:\n\tvoid on_textEdit_textChanged();\n\tvoid on_saveButton_clicked();\n\tvoid on_copyButton_clicked();\n\n\tsignals:\n\tvoid saved(QString path);\n\n\tprivate:\n\tUi::locEditor *ui;\n\t//locHighlighter *locHigh;\n};\n\n\n', '#include "locstuff.h"\n#include <QTextStream>\n#include <QString>\n#include <QFile>\n#include <QDebug>\n#include <QList>\n#include <QRegularExpression>\n\n\nQList<QString>* parseLocFile(QString &path){\n\tQFile file(path);\n\tif (!file.open(QIODevice::ReadOnly | QIODevice::Text)){\n\t\tqCritical() << "Failed to open file" << path << "for parsing.";\n\t\treturn new QList<QString>; //don\'t return nullptr\n\t}\n\n\tQTextStream in(&file);\n\tQList<QString> *fileLocList = new QList<QString>;\n\tQString line;\n\n\twhile(!in.atEnd()) {\n\t\tline = in.readLine();\n\t\t//if(line == "l_english:") continue;\t\t//maybe add other language support? nah, too much work\n\t\tfileLocList->append(line);\n\t}\n\treturn fileLocList;\n}\n\nvoid loadLocFile(QListWidget *activeWidget, QString &path){\n\tQList<QString> *fileLocList = parseLocFile(path);\n\n\tQString entry;\n\tforeach(entry, *fileLocList){\n\t\tactiveWidget->addItem(entry);\n\t}\n\tdelete fileLocList;\n}\n\nvoid saveLocFile(QList<QString> *list, QString& path){\n\t\tQFile file(path);\n\t\tif (!file.open(QIODevice::WriteOnly | QIODevice::Text)){\n\t\t\tqCritical() << "Failed to open file" << path << "for writing.";\n\t\t\treturn;\n\t\t}\n\t\tQTextStream out(&file);\n\t\tout.setEncoding(QStringConverter::Utf8);\t\t\t\t\t\t//maybe unnecessarry?\n\t\tout.setGenerateByteOrderMark(true);\n\n\t\tforeach(QString line, *list){\n\t\t\tout << line << Qt::endl;\n\t\t}\n\t\tout.flush();\n}\n\nQHash<QString, locEntry>* loadLoc(){\n\tQHash<QString, locEntry>* locAll = new QHash<QString, locEntry>;\n\tQSettings settings("muha0644","Kadaif");\n\tsettings.setValue("locDup", "");\n\tQString lang = settings.value("loclang", "english").toString(); //!! add something to change default loclang\n\n\tQDir locDir(".");\t\t\t\t\t\t\t\t\t\t\t\t//!!!!!!!!!\n\tif(!locDir.cd("localisation")){\t\t//what if it doesn\'t exist?\n\t\tif(!locDir.mkdir("localisation")){\n\t\t\tqCritical() << "Failed to create \\"localisation\\" folder. Something is seriously wrong.";\n\t\t\t//should abort now soooo\n\t\t\tdelete locAll; //don\'t want to cause a memory leak...\n\t\t\treturn new QHash<QString, locEntry>; // it\'s better to just return an empty QHash\n\t\t}\n\t\tlocDir.cd("localisation");\n\t}\n\tif(!locDir.cd(lang)){\t\t//what if it doesn\'t exist?\n\t\tif(!locDir.mkdir(lang)){\n\t\t\tqCritical() << "Failed to create \\"localisation/" + lang + "\\" folder. Something is seriously wrong.";\n\t\t\tdelete locAll;\n\t\t\treturn new QHash<QString, locEntry>;\n\t\t}\n\t\tlocDir.cd(lang);\n\t}\n\n\tQStringList files = locDir.entryList(QStringList() << "*.yml",QDir::Files);\n\tforeach(QString filename, files){\t//open each file and add entries to the hashmap\n\t\tQFile file(locDir.absoluteFilePath(filename));\n\t\tif(!file.open(QIODevice::ReadOnly | QIODevice::Text)){\n\t\t\tqCritical() << "Failed to open localisation file" << filename << ":" <<file.errorString();\n\t\t\t//return new QHash<QString, locEntry>;\n\t\t\tcontinue;\n\t\t}\n\t\tQTextStream in(&file);\n\t\tQString line;\n\t\tint lineNum = 0;\n\t\twhile(!in.atEnd()) {\n\t\t\tlineNum++;\n\t\t\tline = in.readLine();\n\t\t\tif(line == "l_english:" || line.trimmed().startsWith("#") || line.trimmed() == "") continue;\n\n\t\t\tauto stuff = line.trimmed().split(QRegularExpression(":\\\\d "));\t//what if there is more than one instance?\n\t\t\tif(stuff.size() != 2){ //if it\'s 1, then it\'s either a comment or just blank space.\n\t\t\t\tqInfo() << "Loc parsing error in file" << filename << "at line" << lineNum << ". Make sure there is only one \':0\' on this line";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlocEntry yeah;\n\t\t\tyeah.file = filename;\n\t\t\tyeah.line = lineNum;\n\t\t\tyeah.key = stuff[0];\n\t\t\tyeah.value = stuff [1];\n\t\t\tif(locAll->contains(stuff[0])){\n\t\t\t\tQString mesg("Duplicate key found: " + stuff[0] + "\\n" + yeah.file + " on line: " + QString::number(yeah.line) + "\\n"\n\t\t\t\t\t\t+ locAll->value(stuff[0]).file + " on line: "  + QString::number(locAll->value(stuff[0]).line));\n\t\t\t\tqWarning() << mesg;\n\t\t\t\tsettings.setValue("locDup", settings.value("locDup").toString() + mesg + "\\n\\n");\n\t\t\t}\n\t\t\tlocAll->insert(stuff[0], yeah);\n\t\t}\n\t}\n\treturn locAll;\n}\n\n', '#pragma once\n#include <QObject>\n#include <QMap>\n#include <QString>\n#include <QtWidgets>\n#include <QTextStream>\n#include <QHash>\n\n\nstruct locEntry{\n\tQString file;\n\tint line;\n\tQString key;\n\tQString value;\n};\n\nQList<QString>* parseLocFile(QString &path);\nvoid loadLocFile(QListWidget *activeWidget, QString &path);\nvoid saveLocFile(QList<QString> *list, QString& path);\nQHash<QString, locEntry>* loadLoc();\nvoid unparseLoc(QString &path, QList<QString> &locFileList);\n', '#include <QApplication>\n#include <QIcon>\n#include <QtDebug>\n#include "mainwindow.h"\n#include <QTreeWidget>\n#include <QSettings>\n#include "dataclass.h"\n\n\nint main(int argc, char *argv[]){\n\tqInstallMessageHandler(messHandler);\n\tQApplication app(argc, argv);\n\tapp.setWindowIcon(QIcon(":/shared/taskbaricon.png"));\n\n\n\tmainWindow mainW;\n\tmainW.show();\n\n\t//QObject::connect(&mainW, &QMainWindow::destroyed, &app, &QApplication::quit);\n\n\treturn app.exec();\n}\n', '#include "mainwindow.h"\n#include "./ui_mainwindow.h"\n#include <QFileSystemModel>\n#include <QString>\n#include <QDebug>\n#include <QFileDialog>\n#include <QFile>\n#include <QSettings>\n#include <QLayout>\n#include <QSpacerItem>\n#include "parser.h"\n#include "config.h"\n#include "loc/locstuff.h"\n#include "loc/loceditor.h"\n#include "gfx/gfxstuff.h"\n\n\nmainWindow::mainWindow(QWidget *parent): QMainWindow(parent), ui(new Ui::mainWindow){\n\tQSettings settings("muha0644","Kadaif");\n\trestoreGeometry(settings.value("main/geometry").toByteArray());\n\trestoreState(settings.value("main/windowState").toByteArray());\n\tui->setupUi(this);\n\n\tQString path = settings.value("absPath").toString();\n\tif(path == ""){\t// if path is not saved make the user chose one.\n\t\tui->openFolder->trigger();\n\t} else {\n\t\tfolderModel = new QFileSystemModel;\n\t\tfolderModel->setRootPath(path);\n\t\tui->fileListThing->setModel(folderModel);\n\t\tui->fileListThing->setRootIndex(folderModel->index(path));\n\t\tui->fileListThing->hideColumn(1);\n\t\tui->fileListThing->hideColumn(2);\n\t\tui->fileListThing->hideColumn(3);\n\t\tQDir::setCurrent(path);\n\n\t\tif(!liveDB.locAll){\t\t//should be the first and only time it\'s initialised\n\t\t\tliveDB.locAll = loadLoc();\n\t\t\tliveDB.gfxAll = loadGfx();\n\t\t}\n\t}\n\tui->splitter->restoreState(settings.value("splitterSizes").toByteArray());\n\n#if COOL_PANEL\n\tui->extraButt->setFrameShape(QFrame::Panel);\n\tui->extraButt->setFrameShadow(QFrame::Raised); //optimised for dark theme on linux\n#endif\n}\n\nmainWindow::~mainWindow(){\n\tQSettings settings("muha0644","Kadaif");\n\tsettings.setValue("main/geometry", saveGeometry());\n\tsettings.setValue("main/windowState", saveState());\n\tdelete folderModel;\n\tdelete ui;\n}\n\nvoid mainWindow::on_actionLocalization_editor_triggered(){\n\tlocEditor *locw = new locEditor;\n\tlocw->setAttribute(Qt::WA_DeleteOnClose);\n\tlocw->setAttribute( Qt::WA_QuitOnClose, false );\n\tlocw->show();\n}\n\nvoid mainWindow::nonononoedit(){\t\t\t//SHOULD HAVE USED AN OBJECT\n\tQListWidget *real = static_cast<QListWidget*>(activeWidget->children()[5]);\n\tint cRow = real->currentRow();\n\tif(cRow < 0) return;\n\tlocEditor *locw = new locEditor(real->item(cRow));\n\tlocw->setAttribute(Qt::WA_DeleteOnClose);\n\tlocw->setAttribute( Qt::WA_QuitOnClose, false );\n\tlocw->show();\n\tlocw->entry.file = cPath.sliced(sizeof("localization"));\n\tconnect(locw, &locEditor::saved, this, &mainWindow::openMainWidget);\n}\n\nvoid mainWindow::nonononodelete(){\t\t\t//THIS SHOULD NOT BE IN `mainWindow`\n\tQListWidget *real = static_cast<QListWidget*>(activeWidget->children()[5]);\n\tQList<QString> *fileLocList = parseLocFile(cPath);\n\n\tint cRow = real->currentRow();\n\n\tif(cRow != -1){//-1 means nothing is selected\n\t\tfileLocList->remove(cRow);\n\t\treal->clear();\n\t\tQString entry;\n\t\tforeach(entry, *fileLocList){\n\t\t\treal->addItem(entry);\n\t\t}\n\t}\n\treal->setCurrentRow(cRow);\n\tsaveLocFile(fileLocList, cPath);\n\tdelete fileLocList;\n}\n\nvoid mainWindow::nononononew(){\t\t\t\t//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\tQListWidget *real = static_cast<QListWidget*>(activeWidget->children()[5]);\n\tQList<QString> *fileLocList = parseLocFile(cPath);\n\n\tfileLocList->insert(real->currentRow()+1, " ");\n\treal->insertItem(real->currentRow()+1, " ");\n\n\tsaveLocFile(fileLocList, cPath);\n\tdelete fileLocList;\n\treal->setCurrentRow(real->currentRow()+1);\n\tnonononoedit();\n}\n\nvoid mainWindow::nonononodup(){\n\tQSettings settings("muha0644", "Kadaif");\n\tQMessageBox msgBox;\n\tmsgBox.setText("Duplicate localization entries:");\n\tmsgBox.setInformativeText(settings.value("locDup").toString());\n\tmsgBox.exec();\n}\n\nvoid mainWindow::nonononoemty(){\n\tQString empty;\n\t///QSettings settings("muha0644", "Kadaif");\n\tforeach(auto entry, liveDB.locAll->values()){\n\t\tif(entry.value.replace("\\"", "").trimmed() == ""){\n\t\t\tempty.append("Empty value found: " + entry.key + "\\nin " + entry.file + " on line " + QString::number(entry.line) + "\\n\\n");\n\t\t};\n\t}\n\tQMessageBox msgBox;\n\tmsgBox.setText("Empty localization keys:");\n\tmsgBox.setInformativeText(empty);\n\tmsgBox.exec();\n}\n\nQWidget* mainWindow::setUpLocList(QString &path){\t\t\t//holy fucking shit i should have used an object...\n\tQListWidget *locListWidget = new QListWidget;\n\tQWidget *holder = new QWidget;\n\tQVBoxLayout *vLayout = new QVBoxLayout(holder);\t\t//do kids get deleted? I think they do.\n\tQHBoxLayout *buttonBar = new QHBoxLayout;\t\t\t//!!! TODO: use unique_ptr\n\tQPushButton *editButt = new QPushButton("Edit");\t//can also pass an icon as an argument.\n\tQPushButton *newButt = new QPushButton("New entry under selection");\n\tQPushButton *deleteButt = new QPushButton("Delete selection");\n\tQSpacerItem *spase = new QSpacerItem(10000,20,QSizePolicy::Preferred);\n#if !NO_TITLE\n\tvLayout->setContentsMargins(5, 2, 0, 0);\n\tQLabel *title = new QLabel(path);\n\tQFont font(FONT_SANS, 12, QFont::Bold);\n\ttitle->setFont(font);\n\tvLayout->addWidget(title);\n#else // avoid segfaults with this one simple trick!\n\tvLayout->addWidget(new QWidget);\n#endif\n\n\t//I don\'t want to convert everything into an object, even though it would be better\n\tconnect(newButt, &QPushButton::clicked, this, &mainWindow::nononononew);\n\tconnect(deleteButt, &QPushButton::clicked, this, &mainWindow::nonononodelete);\n\tconnect(editButt, &QPushButton::clicked, this, &mainWindow::nonononoedit);\n\tconnect(locListWidget, &QListWidget::itemDoubleClicked, this, &mainWindow::nonononoedit);\n\n\n\tbuttonBar->addWidget(newButt);\n\tbuttonBar->addWidget(deleteButt);\n\tbuttonBar->addWidget(editButt);\n\tbuttonBar->addSpacerItem(spase);\n\n\tvLayout->addLayout(buttonBar);\n\tvLayout->addWidget(locListWidget);\n\tui->splitter->addWidget(holder);\n\tloadLocFile(locListWidget, path);\t//do not question why this is here\n\t//amazingly documented code, i know. No need to thank me\n\treturn holder;\n}\n\nvoid mainWindow::on_fileListThing_clicked(const QModelIndex &index){\n\tQSettings settings("muha0644","Kadaif");\n\tcPath = ((QFileSystemModel)ui->fileListThing->model()).filePath(index);\n\tcPath.remove(settings.value("absPath").toString()).remove(0,1);\n}\n\nvoid mainWindow::on_fileListThing_doubleClicked(const QModelIndex &index){\n\topenMainWidget(cPath);\n\twPath = cPath;\n}\n\n//!!!! on_selection_changed will cause issues. navigating with a keyboard does not work\n\nvoid mainWindow::deleteActiveWidget(){\n\tdelete activeWidget;\n\tactiveWidget = nullptr;\n\tfor(auto child: ui->extraButt->children()){\n\t\tdelete child;\n\t};\n\tui->extraButt->setBaseSize(0,0);\t\t//ignoring this for now, will probbably be problematic later...\n\tui->extraButt->resize(0,0);\n\tui->fileListThing->updateGeometry();\n\treturn;\n}\n\nvoid mainWindow::openMainWidget(QString path){\n\tif(parseType(path) == nothing){\t//if nothing will be changed, do not do anything.\n\t\treturn;\n\t}\n\tif(activeWidget){ //something will be changed, delete the old\n\t\tdeleteActiveWidget();\n\t}\n\n\tswitch(parseType(path)){\n\t\tcase loc:{\n\t\t\tactiveWidget = setUpLocList(path);\n\t\t\tQGridLayout *container = new QGridLayout(ui->extraButt);\n\t\t\tQPushButton *checkDup = new QPushButton("Show duplicates");\n\t\t\tQPushButton *findEmty = new QPushButton("Find empty keys");\n\t\t\tconnect(findEmty, &QPushButton::clicked, this, &mainWindow::nonononoemty);\n\t\t\tconnect(checkDup, &QPushButton::clicked, this, &mainWindow::nonononodup);\n\t\t\tcontainer->addWidget(checkDup,0,0);\n\t\t\tcontainer->addWidget(findEmty,0,1);\n\t\t\tbreak;}\n\t\tcase gfx:{\n\t\t\tgfxWidget *gw = new gfxWidget(path);\n\t\t\tactiveWidget = (QWidget*)gw;\n\t\t\tui->splitter->addWidget(activeWidget);\n\t\t\tQGridLayout *container = new QGridLayout(ui->extraButt);\n\t\t\tQPushButton *checkDup = new QPushButton("Show duplicates");\n\t\t\tQPushButton *findEmpty = new QPushButton("Find empty keys");\n\t\t\tconnect(findEmpty, &QPushButton::clicked, gw, &gfxWidget::empty);\n\t\t\tconnect(checkDup, &QPushButton::clicked, gw, &gfxWidget::dup);\n\t\t\tcontainer->addWidget(checkDup,0,0);\n\t\t\tcontainer->addWidget(findEmpty,0,1);\n\t\t\tbreak;}\n\t\tcase image:{\n\t\t\tQWidget *imgW = new QWidget;\n\t\t\tQVBoxLayout *vLayout = new QVBoxLayout(imgW);\n\t\t\tPngView* pngvju = new PngView(pngify(path));\n#if !NO_TITLE\n\t\t\tvLayout->setContentsMargins(5, 2, 0, 0);\n\t\t\tQLabel *title = new QLabel(path);\n\t\t\tQFont font(FONT_SANS, 12, QFont::Bold);\n\t\t\ttitle->setFont(font);\n\t\t\tvLayout->addWidget(title);\n#endif\n\t\t\tvLayout->addWidget(pngvju);\n\t\t\tactiveWidget = imgW;\n\t\t\tui->splitter->addWidget(imgW);\n\t\t\tbreak;}\n\t\tcase nothing:\t//should never reach here\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tQSettings settings("muha0644","Kadaif");\n\tui->splitter->restoreState(settings.value("splitterSizes").toByteArray());\n}\n\nvoid mainWindow::on_openFolder_triggered(){\t//open mod folder in sidebar\n\tQString path = QFileDialog::getOpenFileName(this, "Chose mod folder location:", "", "Mod descriptor file (descriptor.mod)");\n\tif(path == "") return;\n\tpath.chop(sizeof("descriptor.mod"));\n\n\tQSettings settings("muha0644", "Kadaif");\n\tsettings.setValue("absPath", path);\n\tQDir::setCurrent(path);\n\n\tif(this->folderModel) delete this->folderModel;\n\tfolderModel = new QFileSystemModel;\n\tfolderModel->setRootPath(path);\n\tui->fileListThing->setModel(folderModel);\n\tui->fileListThing->setRootIndex(folderModel->index(path));\n\tui->fileListThing->hideColumn(1);\n\tui->fileListThing->hideColumn(2);\n\tui->fileListThing->hideColumn(3);\n\n\tif(!liveDB.locAll){\t\t//should be the first and only time it\'s initialised\n\t\tliveDB.locAll = loadLoc();\n\t\tliveDB.gfxAll = loadGfx();\n\t}\n}\n\n\nvoid mainWindow::on_splitter_splitterMoved(int pos, int index){\n\tQSettings settings("muha0644", "Kadaif");\n\tsettings.setValue("splitterSizes", ui->splitter->saveState());\n}\n\n\nvoid mainWindow::on_newButt_clicked(){\n\tQDir root;\n\tQFileInfo finfo(cPath);\n\tQString newpath;\t//relative path, folder always ends with a /\n\tif(finfo.isFile()){\n\t\t\tnewpath = root.filePath(cPath);\n\t\t\tnewpath.remove(finfo.fileName());\n\t} else newpath = cPath+"/";\n\tif(newpath == "/") newpath = "./";\n\n\tbool ok;\n\tQString text = QInputDialog::getText(this,"" , "Choose a name for the file.\\n If you want to make a new folder, put a \\"/\\" after the name.",\n\t\t\t\t\t\t\t\t\t\t QLineEdit::Normal,"" , &ok);\n\tif(!ok || text.isEmpty()) return;\n\tif(root.exists(newpath+text)){\n\t\tqCritical() << "File \'" + newpath+text + "\' already exists.";\n\t\treturn;\n\t}\n\n\tif(text.endsWith("/")){\t//directory\n\t\tif(!root.mkpath(newpath+text)) qCritical() << "Could not create folder \'" + newpath+text + "\'. Does it already exist?";\n\t\treturn;\n\t}\n\n\tQFile shittyImplementation(newpath+text);//file\n\tif(shittyImplementation.exists()){ //this seems to do nothing, but i am too scared to remove it and too lazy to test it\n\t\tqCritical() << "File \'" + newpath+text + "\' already exists bro.";\n\t\treturn;\n\t}\n\tif(!shittyImplementation.open(QIODevice::WriteOnly | QIODevice::Text)){\n\t\tqCritical() << "Could not create file \'" + newpath+text + "\'";\n\t\treturn;\n\t}\n\tshittyImplementation.close();\n}\n\nvoid mainWindow::on_renameButt_clicked(){\n\tif(cPath==""){\n\t\tqCritical() << "Bruh, how about you select something first?";\n\t\treturn;\n\t}\n\tQDir root;\n\tQFileInfo finfo(cPath);\n\tQString newpath;\n\tnewpath = root.filePath(cPath);\n\tnewpath.remove(finfo.fileName());\n\n\tif(newpath == "/") newpath = "./";\n\n\tbool ok;\n\tQString text = QInputDialog::getText(this,"" , "New name:", QLineEdit::Normal, finfo.fileName(), &ok);\n\tif(!ok || text.isEmpty()) return;\n\tif(root.exists(newpath+text)){\n\t\tqCritical() << "File \'" + newpath+text + "\' already exists.";\n\t\treturn;\n\t}\n\n\tif(finfo.isFile()){\n\t\tQFile::rename(cPath, newpath+text);\n\t\treturn;\n\t} else {\n\t\troot.rename(cPath, newpath+text);\n\t}\n}\n\nvoid mainWindow::on_rmButt_clicked(){\n\t//maybe ask for a confirmation?\n\tif(cPath == wPath){\n\t\twPath = "";\n\t\tdeleteActiveWidget();\n\t}\n\tif(cPath==""){\n\t\tqCritical() << "Bruh, how about you select something first?";\n\t\treturn;\n\t}\n\tQModelIndex index = this->folderModel->index(cPath);\n\tif(!this->folderModel->remove(index)){\n\t\t//deleted the file, if flase that means it\'s likely a folder\n\t\tif(!this->folderModel->rmdir(index)){\n\t\t\tqCritical() << "Could not delete " + cPath + ". Something is seriously wrong. You should panic.";\n\t\t}\n\t}\n\tcPath = "";\n}\n\n', '#pragma once\n#include <QMainWindow>\n#include <QtWidgets>\n#include <QLayout>\n#include "loc/locstuff.h"\n#include "dataclass.h"\n\nQT_BEGIN_NAMESPACE\nnamespace Ui { class mainWindow; }\nQT_END_NAMESPACE\n\nclass mainWindow : public QMainWindow{\n\tQ_OBJECT\n\n\tpublic:\n\tmainWindow(QWidget *parent = nullptr);\n\t~mainWindow();\n\n\tQString cPath;\n\tQString wPath;\n\tdataClass& liveDB = dataClass::getReference();;\n\n\tprivate slots:\n\tvoid on_openFolder_triggered();\n\tvoid on_splitter_splitterMoved(int pos, int index);\n\tvoid on_fileListThing_doubleClicked(const QModelIndex &index);\n\tvoid on_actionLocalization_editor_triggered();\n\tvoid openMainWidget(QString path);\n\tvoid on_fileListThing_clicked(const QModelIndex &index);\n\tvoid on_newButt_clicked();\n\tvoid on_renameButt_clicked();\n\tvoid on_rmButt_clicked();\n\n\tprivate:\n\tvoid deleteActiveWidget();\n\n\tvoid nonononoedit();\n\tvoid nonononodelete();\n\tvoid nononononew();\n\tvoid nonononodup();\n\tvoid nonononoemty();\n\n\tQFileSystemModel *folderModel;\n\tUi::mainWindow *ui;\n\t//QWidget *activeWidget;\n\tQWidget *activeWidget = nullptr;\n\tQWidget *setUpLocList(QString &path);\n};\n', '#include "parser.h"\n#include <QString>\n\nfileType parseType(QString path){\n\tif(path.length() < 4) return nothing;\n\tQString ext = path.last(4);\n\tif(ext == ".gfx"){\t//i swear there was a reason i didnt use a switch statement, i just so happen to have forgoten it...\n\t\treturn gfx;\n\t} else if(ext == ".dds" || ext == ".tga" || ext == ".png" || ext == ".bmp" || ext == ".jpg"){ //yes i realize that png will get converted again to png, i just don\'t care\n\t\treturn image;\n\t} else if(ext == ".yml"){\n\t\treturn loc;\n\t} else if(ext == ".txt"){\n\n\t}\n\treturn nothing;\n};\n', '#pragma once\n#include <QString>\n\nenum fileType{\n\tnothing = 65,\n\tfocus,\n\tgfx,\n\timage,\n\tloc,\n\tdecision,\n\tevent\n};\n\nfileType parseType(QString path);\n']},



 {'name': 'optimetable',
 'full_name': 'Muha0644/optimetable',
 'default_branch': 'master',
 'html_url': 'https://github.com/Muha0644/optimetable',
 'clone_url': 'https://github.com/Muha0644/optimetable.git',
 'description': 'Timetable optimizer program written in Rust.',
 'forks_count': 0,
 'open_issues_count': 0,
 'pushed_at': '2023-09-27T14:54:21Z',
 'topics': [],
 'languages': {'Rust': 5277},
 'readme': '# Timetable Optimizer program\nI made this little thing to learn Rust, but also so i can spend as little time at university as possible.\n\nOptimetable first generates every single valid timetable using a bruteforce depth-first search,\nand then filters the results out based on certain criteria _(in this case minimizing empty time between classes, and also blank days if possible)_\nIt returns an array with possible solutions of equal efficiency.\n\nThe program assumes that each subject has a seperate "lecture" and "lab" class which can be at one or more times, and only one of each has to be attended.\n',
 'structure': {'sha': '7fa0e3c41373b95e892e001c27573e793f26a5ed', 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/trees/7fa0e3c41373b95e892e001c27573e793f26a5ed', 'tree': [{'path': '.gitignore', 'mode': '100644', 'type': 'blob', 'sha': '9026c77a5d5ffb92826b40c97e937c2e66e373b5', 'size': 16, 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/blobs/9026c77a5d5ffb92826b40c97e937c2e66e373b5'}, {'path': 'Cargo.lock', 'mode': '100644', 'type': 'blob', 'sha': 'aa681eac420b95cd9157455cff2adaa553e544c6', 'size': 11026, 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/blobs/aa681eac420b95cd9157455cff2adaa553e544c6'}, {'path': 'Cargo.toml', 'mode': '100644', 'type': 'blob', 'sha': 'd1701cb07cc5de168d04f96856f148f36775e4b2', 'size': 208, 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/blobs/d1701cb07cc5de168d04f96856f148f36775e4b2'}, {'path': 'README.md', 'mode': '100644', 'type': 'blob', 'sha': 'c7cc5f3114047fd4dd9bdc334ab109d1ca2624e8', 'size': 601, 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/blobs/c7cc5f3114047fd4dd9bdc334ab109d1ca2624e8'}, {'path': 'src', 'mode': '040000', 'type': 'tree', 'sha': '09519ea0aa0d8656ee67cd4d65c237372c47e944', 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/trees/09519ea0aa0d8656ee67cd4d65c237372c47e944'}, {'path': 'src/classes.rs', 'mode': '100644', 'type': 'blob', 'sha': '68b6035275f7a8fcac5a9e9d1f3cdf8b5a8ee699', 'size': 1234, 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/blobs/68b6035275f7a8fcac5a9e9d1f3cdf8b5a8ee699'}, {'path': 'src/main.rs', 'mode': '100644', 'type': 'blob', 'sha': 'f836a9ad6c6a69b8fd4678565d3fa7ac4df6e91b', 'size': 4043, 'url': 'https://api.github.com/repos/Muha0644/optimetable/git/blobs/f836a9ad6c6a69b8fd4678565d3fa7ac4df6e91b'}], 'truncated': False}, 'repo_data': ['use crate::{Subject, D};\n\npub fn empty_day_incentive() -> usize {\n\treturn 2;\t//the larger the number, the bettr the algorithm will rank timetables with empty days.\n}\t//1 and 2 work really well, put 0 to disable empty day prioritization.\n\npub fn get_subjects() -> Vec<Subject> {\n\treturn Vec::from([  //todo: make this shit less tedious to do\n\t\tSubject{\n\t\t\tname:\t"Calc 2".to_string(),\n\t\t\tsched:\t[(D::Mon, 12,14), (D::Mon, 15,17)].to_vec(),\n\t\t\tsched_l:[(D::Mon, 15,16), (D::Tue, 14,15), (D::Thu, 9,10)].to_vec()\n\t\t},\n\t\tSubject{\n\t\t\tname:\t"DBI".to_string(),\n\t\t\tsched:\t[(D::Mon, 9,10), (D::Mon, 11,12)].to_vec(),\n\t\t\tsched_l:[(D::Tue, 9,10), (D::Tue, 11,12), (D::Tue, 13,14), (D::Wed, 9,10),\n\t\t\t\t\t (D::Thu, 9,10), (D::Thu, 11,12), (D::Thu, 17,18)].to_vec(),\n\t\t},\n\t\tSubject{\n\t\t\tname: \t"Prog 2".to_string(),\n\t\t\tsched:\t[(D::Wed, 17,19), (D::Fri, 17,19)].to_vec(),\n\t\t\tsched_l:[(D::Tue, 9,10), (D::Thu, 9,10), (D::Thu, 11,12), (D::Thu, 13,14),\n\t\t\t\t\t (D::Fri, 9,10)].to_vec()\n\t\t},\n\t\tSubject{\n\t\t\tname:\t"Phys 2".to_string(),\n\t\t\tsched:\t[(D::Wed, 15,16)].to_vec(),\n\t\t\tsched_l:[(D::Wed, 17,18), (D::Thu, 17,18)].to_vec()\n\t\t},\n\t\tSubject{\n\t\t\tname:\t"SR&W".to_string(),\n\t\t\tsched:\t[(D::Tue, 14,15)].to_vec(),\n\t\t\tsched_l:[(D::Tue, 16,16)].to_vec()\n\t\t}\n\t]);\n}', 'pub mod classes;\n#[macro_use] extern crate prettytable;\nuse classes::{get_subjects, empty_day_incentive};\nuse prettytable::Table;\n\ntype Timetable = [[String; 11]; 5];\n\n#[derive(Copy, Clone,PartialEq)]\nenum D{\n\tMon = 0,\n\tTue = 1,\n\tWed = 2,\n\tThu = 3,\n\tFri = 4\n}\n#[derive(Clone)]\npub struct Subject{\n\tname:\tString,\n\tsched:\tVec<(D, usize, usize)>,\n\tsched_l:Vec<(D, usize, usize)>\n}\n\n\nfn check_conflict(class: &(D, usize, usize), timetable: &Timetable) -> bool{\n\tfor i in class.1 ..= class.2 {\n\t\tif timetable[class.0 as usize][i-9] != "" {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif class.0  == D::Fri && ([12, 13].contains(&class.1) || [12, 13].contains(&class.2)) {\n\t\treturn true\n\t}\n\n\treturn false;\n}\n\nfn add_class(class: &(D, usize, usize), name: String, timetable: &mut Timetable){\n\tfor i in class.1 ..= class.2 {\n\t\ttimetable[class.0 as usize][i-9] = name.clone();\n\t}\n}\n\nfn remember(timetable: Option<Timetable>) -> Vec<Timetable>{\n\tstatic mut ALL_TIMETABLES: Vec<Timetable> = Vec::new();\n\tunsafe {\n\t\tif timetable.is_some() {\n\t\t\tALL_TIMETABLES.push(timetable.unwrap());\n\t\t}\n\t\treturn ALL_TIMETABLES.clone();\n\t}\n}\n\nfn generate_perm(subjects: Vec<Subject>, timetable: Timetable){\n\tif subjects.len() == 1{\n\t\tfor each_sched in &subjects[0].sched{\n\t\t\tif check_conflict(&each_sched, &timetable){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet mut temptable = timetable.clone();\n\t\t\tadd_class(each_sched, subjects[0].name.clone(), &mut temptable);\n\t\t\tfor each_lab in &subjects[0].sched_l{\n\t\t\t\tif check_conflict(&each_lab, &temptable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet mut temp2ble = temptable.clone();\n\t\t\t\tadd_class(each_lab, subjects[0].name.clone() + " lab", &mut temp2ble);\n\t\n\t\t\t\tremember(Some(temp2ble));\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tfor each_sched in &subjects[0].sched{\n\t\tif check_conflict(&each_sched, &timetable){\n\t\t\tcontinue;\n\t\t}\n\t\tlet mut temptable = timetable.clone();\n\t\tadd_class(each_sched, subjects[0].name.clone(), &mut temptable);\n\t\tfor each_lab in &subjects[0].sched_l{\n\t\t\tif check_conflict(&each_lab, &temptable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet mut temp2ble = temptable.clone();\n\t\t\tadd_class(each_lab, subjects[0].name.clone() + " lab", &mut temp2ble);\n\n\t\t\tlet mut subjects_minus = subjects.clone();\n\t\t\tsubjects_minus.remove(0);\n\t\t\t//early quit if no class or lab can be added to timetable?\n\t\t\tgenerate_perm(subjects_minus, temp2ble.clone());\n\t\t}\n\t}\n}\n\nfn print_table(timetable: &Timetable){\n\tlet mut table = Table::new();\n\ttable.add_row(row![9,10,11,12,13,14,15,16,17,18,19]);\n\tfor day in timetable {\n\t\tlet mut vec: Vec<prettytable::Cell> = vec![];\n\t\tfor class in day {\n\t\t\tvec.push(prettytable::Cell::new(class).style_spec("bFg"));\n\t\t}\n\t\ttable.add_row(prettytable::Row::new(vec));\n\t}\n\ttable.printstd();\n}\nfn main() {\n\tlet subjects = get_subjects();\n\n\tlet timetable: Timetable = Default::default();\n\tgenerate_perm(subjects, timetable);\n\t\n\tlet allofthem = remember(None);\n\n\tlet empty_day: [String; 11] = Default::default();\n\tlet mut besttables: Vec<Timetable> = vec![];\n\tlet mut secbest: Vec<Timetable> = vec![];\n\tlet mut bestsize: usize = 9999;\n\tfor each in &allofthem { //find the one with smallest time\n\t\tlet mut length = 0;\n\t\tfor day in each {\n\t\t\tif day == &empty_day {\n\t\t\t\tlength -= empty_day_incentive(); //add incentive to prefer empty days\n\t\t\t\tcontinue;\n\t\t\t};\n\t\t\tlet mut begin = 0;\n\t\t\tlet mut end = 10;\n\t\t\twhile day[begin] == "" || day[end] == "" {\n\t\t\t\tif day[begin] == "" {begin += 1;};\n\t\t\t\tif day[end] == "" {end -= 1;};\n\t\t\t}\n\t\t\tlength += end - begin + 1;\n\t\t}\n\t\tif length < bestsize {\n\t\t\t//secbest.clear();\n\t\t\tsecbest = besttables.clone();\n\t\t\t//besttables.clear();\n\t\t\tbesttables.push(each.clone());\n\t\t\tbestsize = length;\n\t\t} else if length == bestsize {\n\t\t\tbesttables.push(each.clone());\n\t\t}\n\t}\n\n\tif besttables.is_empty() {\n\t\tprintln!("ERROR: no non-conflicting solution could be found. Are the subjects entered in correctly?")\n\t}\n\tprintln!("Best score: {}", bestsize);\n\t//print best\n\tfor each in besttables {\n\t\tprintln!("Solution:");\n\t\tprint_table(&each);\n\t}\n\t//print second best\n\t//for each in secbest {\n\t//\tprintln!("Second best Solution:");\n\t//\tprint_table(&each);\n\t//}\n}\n']},





 {'name': 'svvt-project',
 'full_name': 'Muha0644/svvt-project',
 'default_branch': 'master',
 'html_url': 'https://github.com/Muha0644/svvt-project',
  'clone_url': 'https://github.com/Muha0644/svvt-project.git',
   'description': 'Project source for Software, Verification, Validation, and Testing.  - Muhamed Muliƒá & Aldin Vi≈°njiƒá',
   'forks_count': 0,
   'open_issues_count': 0,
   'pushed_at': '2024-10-17T21:10:50Z',
    'topics': [],
    'languages': {},
    'readme': None,
    'structure': {'message': 'Git Repository is empty.', 'documentation_url': 'https://docs.github.com/rest/git/trees#get-a-tree', 'status': '409'},
     'repo_data': []
     }
 ]